Project Part A

Cash Stramel
Diana O'Haver
Kelby Faessler

-------------------------------
explain testIsValid() function:
-------------------------------

testIsValid() is an overloaded function
  the first version returns void and accepts two input arguments, but it called the second version of testIsValid() and the calls function setUp();
  the second version of isValid accepts two arguments:
    the first argument is an array of arrays of ResultPair[] objects, which consist of URLs and true/false values indicated their validity
    the second argument is an option

    inside testIsValid(Object[], long):
      create instance of UrlValidator object
      create different URL's which are combinations of the different elements of the five arrays of ResultPair[] objects
        1. testUrlScheme [length = 9]
        2. testUrlAuthority [length = 19]
        3. testUrlPort [length = 7]
        4. testPath [length = 10]
        5. testUrlQuery [length = 3]

-------------------------------
how many total URLs is it testing?
-------------------------------

On the surface the answer would appear to be 9*19*7*10*3 = 35910.
However, when we inserted a counter it was only 8*19*7*10*3 = 31920.
The code doesn't test the URL's starting with blank (the last element in testUrlScheme[]).

-------------------------------
give an example of a valid URL being tested
-------------------------------

http://www.google.com:80/test1?action=view

-------------------------------
give an example of an invalid URL being tested
-------------------------------

http://www.google.com:80/..?action=view

-------------------------------
how is it building all the URLs?
-------------------------------

it's combining different elements from each of the five arrays of ResultPair[] objects

-------------------------------
are these tests very different than unit/card tests we wrote in terms of concepts & complexity?
-------------------------------

The concepts are similar because we are feeding in different valid and invalid inputs including
boundary conditions and we are able to compare the output to expected results.

The tests are less complex in the sense that we are just doing simple string validation compared
to dominion that is working with objects and has greater chance of more serious errors.

Additionally, the results are simple boolean values.  In the dominion testing the results are
game states (structs) with multiple variable attributes.
