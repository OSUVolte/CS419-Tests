        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "stdlib.h"
        -:    2:#include "stdio.h"
        -:    3:#include "string.h"
        -:    4:#include "math.h"
        -:    5:
        -:    6:#include "dominion.h"
        -:    7:#include "dominion_helpers.h"
        -:    8:#include "unitTestLib.h"
        -:    9:
        -:   10:/* Function to Be Tested
        -:   11: *
        -:   12: * Description: This function checks the game state to see if the game should 
        -:   13: *    be over. If the province count is 0, the game ends. If three supply 
        -:   14: *    piles are at 0, the game ends.
        -:   15: *
        -:   16: *    The way it checks is by:
        -:   17: *	 - IF supplyCount of provinces is 0, RETURN 1 //state accessed
        -:   18: *	 FOR LOOP - for each of the supply piles 0-25
        -:   19: *	 - If supplyCount of supply is 0, count++     //state accessed
        -:   20: *	 - If count >= 3 (3 supply piles counted), RETURN 1
        -:   21: *	 RETURN 0 if function hasn't returned 1
        -:   22: *
        -:   23: * Eval: 
        -:   24: *
        -:   25: * Game state is only read, and should remain unchanged.
        -:   26: * Only a 1 or a 0 is returned.
        -:   27: * If there are 0 cards in the province pile, a 1 was returned
        -:   28: * If there are 3 or more piles with 0 supply, a 1 is returned
        -:   29: * If the 2 end game conditions aren't met, a 0 is returned
        -:   30: * It appears that the check for 3 empty supplies only checks the first 24
        -:   31: *    supplies and not up to the 27 supplies.
        -:   32: */
        -:   33:/*
        -:   34:int isGameOver(struct gameState *state) {
        -:   35:  int i;
        -:   36:  int j;
        -:   37:	
        -:   38:  //if stack of Province cards is empty, the game ends
        -:   39:  if (state->supplyCount[province] == 0)
        -:   40:    {
        -:   41:      return 1;
        -:   42:    }
        -:   43:
        -:   44:  //if three supply pile are at 0, the game ends
        -:   45:  j = 0;
        -:   46:  for (i = 0; i < 25; i++)
        -:   47:    {
        -:   48:      if (state->supplyCount[i] == 0)
        -:   49:	{
        -:   50:	  j++;
        -:   51:	}
        -:   52:    }
        -:   53:  if ( j >= 3)
        -:   54:    {
        -:   55:      return 1;
        -:   56:    }
        -:   57:
        -:   58:  return 0;
        -:   59:}
        -:   60:*/
        -:   61:
function basicReturnTest called 4 returned 100% blocks executed 71%
        4:   62:int basicReturnTest(struct gameState* state){
        -:   63:
        -:   64:
        4:   65:   int retVal = isGameOver(state);
call    0 returned 100%
        4:   66:   int gameOver = checkGameOver(state);
call    0 returned 100%
        -:   67:   //Only non-zero return value
        4:   68:   if(retVal != gameOver){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   69:      printf("basicReturnTest -1: Game Over Conditions Don't Match\n");
call    0 never executed
    #####:   70:      return -1;
        -:   71:   }
        4:   72:   return 0;
        -:   73:}
        -:   74:
function allNonProvinceEmptyReturnTest called 3 returned 100% blocks executed 80%
        3:   75:int allNonProvinceEmptyReturnTest(struct gameState* state){
        -:   76:
        -:   77:   int i;
       84:   78:   for(i = 0; i < treasure_map+1; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       81:   79:      state->supplyCount[i] = 0;
        -:   80:   }
        3:   81:   state->supplyCount[province] = 1;
        -:   82:
        3:   83:   int retVal = isGameOver(state);
call    0 returned 100%
        3:   84:   if(retVal != checkGameOver(state)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   85:      printf("allNonProvinceEmptyReturnTest -1: Game Over Evaluation Differs\n");
call    0 never executed
    #####:   86:      return -1;
        -:   87:   }
        -:   88:
        3:   89:   return 0;
        -:   90:}
        -:   91:
function noEmptySuppliesReturnTest called 9 returned 100% blocks executed 80%
        9:   92:int noEmptySuppliesReturnTest(struct gameState* state){
        -:   93:
        -:   94:   int i;
      252:   95:   for(i = 0; i < treasure_map+1; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      243:   96:      state->supplyCount[i] = 1;
        -:   97:   }
        -:   98:
        9:   99:   int retVal = isGameOver(state);
call    0 returned 100%
        9:  100:   if(retVal != checkGameOver(state)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  101:      printf("noEmptySuppliesReturnTest -1: Game Over Evaluation Differs\n");
call    0 never executed
    #####:  102:      return -1;
        -:  103:   }
        -:  104:  
        9:  105:   return 0;
        -:  106:}
        -:  107:
        -:  108:
function stateTest called 3 returned 100% blocks executed 71%
        3:  109:int stateTest(struct gameState* state){
        -:  110:
        3:  111:   struct gameState* cpy = (struct gameState*)(malloc(sizeof(struct gameState)));
        3:  112:   memcpy(cpy, state, sizeof(struct gameState));
        -:  113:
        3:  114:   isGameOver(state);
call    0 returned 100%
        3:  115:   int retVal = checkState(cpy, state);
call    0 returned 100%
        -:  116:
        3:  117:   if(retVal){ 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  118:      printf("stateTest %i: State error\n", retVal);
call    0 never executed
    #####:  119:      return -1;
        -:  120:   }
        -:  121:
        3:  122:   free(cpy);
        3:  123:   return 0;
        -:  124:}
        -:  125:
function unitTest called 1 returned 100% blocks executed 90%
        1:  126:int unitTest(){
        -:  127:
        1:  128:   printf("\n+--------------------------------UNIT TEST 3----------------------------+\n");
call    0 returned 100%
        -:  129:   //Create Zeroed Gamestate;
        1:  130:   struct gameState* testState = (struct gameState*)(malloc(sizeof(struct gameState)));
        1:  131:   memset(testState, 0, sizeof(struct gameState));
        1:  132:   int i, retVal = 0;
        -:  133:
        1:  134:   printf("+------zeroStateTest--------+\n\n");
call    0 returned 100%
        -:  135:   //Zero Test
        1:  136:   retVal = basicReturnTest(testState);
call    0 returned 100%
        1:  137:   if(retVal != 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  138:      printf("unitTest %i: Failed Zero State Test\n", retVal);
call    0 never executed
        -:  139:      //return -1;
        -:  140:   } else {
        1:  141:      printf("zeroStateTest: Successful\n");
call    0 returned 100%
        -:  142:   }
        -:  143:
        1:  144:   printf("\n+--------basicReturnTest----------+\n\n");
call    0 returned 100%
        -:  145:   //Checks to ensure cards count accross a variety of states for a variety of players
        4:  146:   for(i = 2; i <= 4; i++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  147:      setupRandomTestState(i, testState);
call    0 returned 100%
        3:  148:      retVal = basicReturnTest(testState);
call    0 returned 100%
        3:  149:      if(retVal){   
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:	 printf("unitTest %i: Failed Basic Return Test\n", retVal);
call    0 never executed
        -:  151:	 //return -2;
        -:  152:      } else {
        3:  153:	 printf("basicReturnTest (%i players): Successful\n", i);
call    0 returned 100%
        -:  154:      }
        -:  155:   }
        -:  156:
        1:  157:   printf("\n+--------allNonProvinceEmptyReturnTest----------+\n\n");
call    0 returned 100%
        -:  158:   //Checks to ensure cards count accross a variety of states for a variety of players
        4:  159:   for(i = 2; i <= 4; i++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  160:      setupRandomTestState(i, testState);
call    0 returned 100%
        3:  161:      retVal = allNonProvinceEmptyReturnTest(testState);
call    0 returned 100%
        3:  162:      if(retVal){   
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  163:	 printf("unitTest %i: Failed All Non Province Empty Return Test\n", retVal);
call    0 never executed
        -:  164:	 //return -3;
        -:  165:      } else {
        3:  166:	 printf("allNonProvinceEmptyReturnTest (%i players): Successful\n", i);
call    0 returned 100%
        -:  167:      }
        -:  168:   }
        -:  169:
        1:  170:   printf("\n+--------noEmptySuppliesReturnTest----------+\n\n");
call    0 returned 100%
        -:  171:   //Checks to ensure cards count accross a variety of states for a variety of players
        4:  172:   for(i = 2; i <= 4; i++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  173:      setupRandomTestState(i, testState);
call    0 returned 100%
        3:  174:      retVal = noEmptySuppliesReturnTest(testState);
call    0 returned 100%
        3:  175:      if(retVal){   
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  176:	 printf("unitTest %i: Failed No Empty Supplies Return Test\n", retVal);
call    0 never executed
        -:  177:	 //return -4;
        -:  178:      } else {
        3:  179:	 printf("noSuppliesEmptyReturnTest (%i players): Successful\n", i);
call    0 returned 100%
        -:  180:      }
        -:  181:   }
        -:  182:
        -:  183:
        1:  184:   printf("\n+--------provinceEmptyReturnTest----------+\n\n");
call    0 returned 100%
        -:  185:   //Checks to ensure cards count accross a variety of states for a variety of players
        4:  186:   for(i = 2; i <= 4; i++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  187:      setupRandomTestState(i, testState);
call    0 returned 100%
        3:  188:      noEmptySuppliesReturnTest(testState); //Sets all supplies to 1
call    0 returned 100%
        3:  189:      testState->supplyCount[province] = 0;
        -:  190:
        3:  191:      if(checkGameOver(testState) != isGameOver(testState)){   
call    0 returned 100%
call    1 returned 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  192:	 printf("unitTest -5: Failed No Empty Supplies Return Test\n");
call    0 never executed
        -:  193:	 //return -5;
        -:  194:      } else {
        3:  195:	 printf("provinceEmptyReturnTest (%i players): Successful\n", i);
call    0 returned 100%
        -:  196:      }
        -:  197:   }
        -:  198:
        1:  199:   printf("\n+--------SpecificStateTest----------+\n\n");
call    0 returned 100%
        -:  200:   //Checks to ensure cards count accross a variety of states for a variety of players
        4:  201:   for(i = 2; i <= 4; i++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  202:      setupRandomTestState(i, testState);
call    0 returned 100%
        3:  203:      noEmptySuppliesReturnTest(testState); //Sets all supplies to 1
call    0 returned 100%
        -:  204:      int j;
       12:  205:      for(j = 24; j < treasure_map+1; j++){ //Sets top 3 supplies to 0
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        9:  206:	 testState->supplyCount[j] = 0;
        -:  207:      }
        3:  208:      if(checkGameOver(testState) != isGameOver(testState)){   
call    0 returned 100%
call    1 returned 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        3:  209:	 printf("specificStateTest -1: Failed Specific State Test\n");
call    0 returned 100%
        -:  210:	 //return -6;
        -:  211:      } else {
    #####:  212:	 printf("provinceEmptyReturnTest (%i players): Successful\n", i);
call    0 never executed
        -:  213:      }
        -:  214:   }
        -:  215:
        1:  216:   printf("\n+--------stateTest----------+\n\n");
call    0 returned 100%
        -:  217:   //Checks to ensure no values in current state are changed after function
        4:  218:   for(i = 2; i <= 4; i++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  219:      setupRandomTestState(i, testState);
call    0 returned 100%
        3:  220:      retVal = stateTest(testState);
call    0 returned 100%
        3:  221:      if(retVal){   
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  222:	 printf("unitTest %i: Failed State Test\n", retVal);
call    0 never executed
        -:  223:	 //return -7;
        -:  224:      } else {
        3:  225:	 printf("stateTest (%i players): Successful\n", i);
call    0 returned 100%
        -:  226:      }
        -:  227:   }
        -:  228:
        1:  229:   return 0;
        -:  230:}
        -:  231:
function main called 1 returned 100% blocks executed 100%
        1:  232:int main(){
        1:  233:   int retVal = unitTest();
call    0 returned 100%
        1:  234:   printf("Outcome: %i\n", retVal);
call    0 returned 100%
        1:  235:   return retVal;
        -:  236:}
        -:  237:   
