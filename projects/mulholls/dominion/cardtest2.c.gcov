        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "stdlib.h"
        -:    2:#include "stdio.h"
        -:    3:#include "string.h"
        -:    4:#include "math.h"
        -:    5:#include "time.h"
        -:    6:#include "assert.h"
        -:    7:
        -:    8:#include "rngs.h"
        -:    9:#include "dominion.h"
        -:   10:#include "dominion_helpers.h"
        -:   11:#include "unitTestLib.h"
        -:   12:
        -:   13:/* Function to Be Tested
        -:   14: *
        -:   15: * Description: This card should discard the smithy card from the players hand
        -:   16: * 		and add 3 additional cards to their hand.
        -:   17: *
        -:   18: *    The way it should work is:
        -:   19: *			-A temporary hand is created to hold drawn cards
        -:   20: *			-drawCard is run on player 3 times, and the new card is copied into
        -:   21: *				temporary hand
        -:   22: *			-And then the smithy card is discarded
        -:   23: *
        -:   24: * Eval:
        -:   25: *
        -:   26: *	The temporary hand doesn't seem necessary, and seems like it will break the base functionality
        -:   27: *	3 cards are discarded
        -:   28: *	The discardCard function call is wrong, its setting the cardDrawn variable in the trash flag
        -:   29: *	The discardCard function call is discarding from the players HAND not the temp hand
        -:   30: */
        -:   31:void smithyCard(struct gameState*, int, int);
        -:   32:/*void smithyCard(struct gameState* state, int currentPlayer, int handPos){
        -:   33:   int cardDrawn;
        -:   34:   int temphand[MAX_HAND];
        -:   35:
        -:   36:   int i;
        -:   37:   //+3 Cards
        -:   38:   for (i = 0; i < 3; i++)
        -:   39:   {
        -:   40:      drawCard(currentPlayer, state);
        -:   41:      cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];
        -:   42:      temphand[i] = cardDrawn;
        -:   43:   }
        -:   44:   
        -:   45:   for(i = 0; i < 3; i++){
        -:   46:      cardDrawn = temphand[i];		  
        -:   47:      //discard card from hand
        -:   48:      discardCard(handPos, currentPlayer, state, cardDrawn);
        -:   49:   }
        -:   50:   return;
        -:   51:}
        -:   52:*/
function basicTest called 1 returned 100% blocks executed 72%
        1:   53:int basicTest(struct gameState* state){
        -:   54:
        1:   55:   state->numPlayers = 2;
        1:   56:   state->deckCount[0] = 27;
        -:   57:
        -:   58:   int i;
        -:   59:
       28:   60:   for(i = 0;  i < state->deckCount[0]; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:   61:      state->deck[0][i] = i;
        -:   62:   }
        1:   63:   state->handCount[0] = 5;
        6:   64:   for(i = 5;  i < 5 + state->handCount[0]; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:   65:      state->hand[0][i-5] = smithy;
        -:   66:   }
        1:   67:   state->discardCount[0] = 10;
       11:   68:   for(i = 0;  i < state->discardCount[0]; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:   69:      state->discard[0][i] = i;
        -:   70:   }
        -:   71:
        1:   72:   struct gameState* cpy = (struct gameState*)(malloc(sizeof(struct gameState)));
        1:   73:   memcpy(cpy, state, sizeof(struct gameState));
        -:   74:
        1:   75:   smithyCard(state, 0, 0);
call    0 returned 100%
        -:   76:
        -:   77:   //Draw 3 cards, discard smithy
        1:   78:   if(state->handCount[0] != cpy->handCount[0]+2){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   79:	   free(cpy);
        1:   80:	   return -1;
        -:   81:   }
        -:   82:   //Discard Count + smithy
    #####:   83:   if(state->discardCount[0] != cpy->discardCount[0] +1){
branch  0 never executed
branch  1 never executed
    #####:   84:	   free(cpy);
    #####:   85:	   return -2;
        -:   86:   }
        -:   87:
    #####:   88:   if(state->discard[0][state->discardCount[0]-1] != smithy){
branch  0 never executed
branch  1 never executed
    #####:   89:	   return -3;
        -:   90:   }
        -:   91:   //Net card change is plus 2
    #####:   92:   free(cpy);
    #####:   93:   return 0;
        -:   94:}
        -:   95:
function _stateTestHelper called 3 returned 100% blocks executed 38%
        3:   96:int _stateTestHelper(struct gameState* state, struct gameState* cpy, int i){
        -:   97:   int j;
        3:   98:   int retVal = abs(checkState(cpy, state));
call    0 returned 100%
        -:   99:
        3:  100:   switch (retVal){
branch  0 taken 33%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 33%
branch  7 taken 0%
branch  8 taken 33%
        -:  101:
        -:  102:     case 11:
      501:  103:		 for(j = 0; j < MAX_HAND; j++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      500:  104:			state->hand[i][j] = cpy->hand[i][j];
        -:  105:		 }
        1:  106:		 return 11;
        -:  107:
        -:  108:     case 12:
    #####:  109:		 state->handCount[i] = cpy->handCount[i];
    #####:  110:		 return 12;
        -:  111:
        -:  112:     case 13:
    #####:  113:		 for(j = 0; j < MAX_DECK; j++){
branch  0 never executed
branch  1 never executed
    #####:  114:			state->discard[i][j] = cpy->discard[i][j];
        -:  115:		 }
    #####:  116:		 return 13;
        -:  117:
        -:  118:     case 14:
    #####:  119:		 state->discardCount[i] = cpy->discardCount[i];
    #####:  120:		 return 14;
        -:  121:
        -:  122:     case 15:
    #####:  123:    	  for(j = 0; j < MAX_DECK; j++){
branch  0 never executed
branch  1 never executed
    #####:  124:    		  state->playedCards[j] = cpy->playedCards[j];
        -:  125:    	  }
    #####:  126:		 return 15;
        -:  127:
        -:  128:     case 16:
    #####:  129:		 state->playedCardCount = cpy->playedCardCount;
    #####:  130:		 return 16;
        -:  131:
        -:  132:     case 17:
        1:  133:    	 state->deckCount[i] = cpy->deckCount[i];
        1:  134:    	 return 17;
        -:  135:
        -:  136:     case 18:
        -:  137:
    #####:  138:		 for(j = 0; j < MAX_DECK; j++){
branch  0 never executed
branch  1 never executed
    #####:  139:			 state->deck[i][j] = cpy->deck[i][j];
        -:  140:		 }
    #####:  141:		 return 18;
        -:  142:
        -:  143:      default:
        1:  144:	 if(retVal){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  145:	    return retVal;
        -:  146:	 } else {
        1:  147:	    return 0;
        -:  148:	 }
        -:  149:   }
        -:  150:}
        -:  151:
function _stateTrackerChecker called 1 returned 100% blocks executed 100%
        1:  152:int _stateTrackerChecker(int* tracker){
        -:  153:   int i;
        1:  154:   int count = 0;
       20:  155:   for(i = 0; i < 19; i++){
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       19:  156:      if(tracker[i] > 0){
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        2:  157:    	  count++;
        -:  158:      }
        -:  159:   }
        1:  160:   return count;
        -:  161:}
        -:  162:
function stateTest called 1 returned 100% blocks executed 50%
        1:  163:int stateTest(struct gameState* state, int expectedStateChanges){
        -:  164:
        1:  165:   int* stateTracker = (int*)(malloc(19*sizeof(int)));
        1:  166:   memset(stateTracker, 0, 19*sizeof(int));
        -:  167:
        -:  168:   int i, retVal;
        1:  169:   state->numPlayers = 2;
        1:  170:   state->deckCount[0] = 27;
        -:  171:
        -:  172:   //Deck doesn't matter
       28:  173:   for(i = 0;  i < state->deckCount[0]; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  174:      state->deck[0][i] = i;
        -:  175:   }
        -:  176:   //Put Smithy into hand
        1:  177:   state->handCount[0] = 5;
        6:  178:   for(i = 5;  i < 5 + state->handCount[0]; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  179:      state->hand[0][i-5] = smithy;
        -:  180:   }
        1:  181:   state->discardCount[0] = 10;
       11:  182:   for(i = 0;  i < state->discardCount[0]; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  183:      state->discard[0][i] = i;
        -:  184:   }
        -:  185:
        1:  186:   struct gameState* cpy = (struct gameState*)(malloc(sizeof(struct gameState)));
        1:  187:   memcpy(cpy, state, sizeof(struct gameState));
        -:  188:
        1:  189:   smithyCard(state, 0, 0);
call    0 returned 100%
        -:  190:   do{
        -:  191:
        3:  192:      retVal = _stateTestHelper(state, cpy, 0);
call    0 returned 100%
        3:  193:      if(retVal){
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        2:  194:    	  stateTracker[retVal]++;
        -:  195:    	  //Unpredictable state change
        2:  196:    	  if(stateTracker[retVal] > 1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  197:    		  printf("stateTest %i: Can't Clear State Error\n", retVal);
call    0 never executed
    #####:  198:    		  return -retVal;
        -:  199:    	  }
        -:  200:      }
        3:  201:   } while (retVal);
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  202:
        1:  203:   int sc = _stateTrackerChecker(stateTracker);
call    0 returned 100%
        -:  204:   //Hand Should change
        1:  205:   if(!stateTracker[11]){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  206:	   return -1;
        -:  207:   }
        -:  208:   //Hand Count Should CHange
        1:  209:   if(!stateTracker[12]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  210:	   return -2;
        -:  211:   }
        -:  212:   //discard should change
    #####:  213:   if(!stateTracker[13]){
branch  0 never executed
branch  1 never executed
    #####:  214:	   return -3;
        -:  215:   }
        -:  216:   //discard count
    #####:  217:   if(!stateTracker[14]){
branch  0 never executed
branch  1 never executed
    #####:  218:	   return -4;
        -:  219:   }
        -:  220:   //playedCards
    #####:  221:   if(!stateTracker[15]){
branch  0 never executed
branch  1 never executed
    #####:  222:	   return -5;
        -:  223:   }
        -:  224:   //PlayedCardCount
    #####:  225:   if(!stateTracker[16]){
branch  0 never executed
branch  1 never executed
    #####:  226:	   return -6;
        -:  227:   }
        -:  228:   //deckCount
    #####:  229:   if(!stateTracker[17]){
branch  0 never executed
branch  1 never executed
    #####:  230:	   return -7;
        -:  231:   }
        -:  232:   //deck should change
    #####:  233:   if(!stateTracker[18]){
branch  0 never executed
branch  1 never executed
    #####:  234:	   return -8;
        -:  235:   }
        -:  236:   //If there isn't an expected number of state changes...
    #####:  237:   if(sc != expectedStateChanges){
branch  0 never executed
branch  1 never executed
    #####:  238:	   printf("stateTest -1: State error, %i Wrong Changes\n", sc-expectedStateChanges);
call    0 never executed
    #####:  239:	   return -9;
        -:  240:   }
        -:  241:
        -:  242:
    #####:  243:   free(stateTracker);
    #####:  244:   free(cpy);
    #####:  245:   return 0;
        -:  246:}
        -:  247:
function discardTest called 1 returned 100% blocks executed 81%
        1:  248:int discardTest(struct gameState* state){
        -:  249:
        1:  250:   state->numPlayers = 2;
        1:  251:   state->deckCount[0] = 27;
        -:  252:
        -:  253:   int i;
        -:  254:
       28:  255:   for(i = 0;  i < state->deckCount[0]; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  256:      state->deck[0][i] = i;
        -:  257:   }
        1:  258:   state->handCount[0] = 5;
        6:  259:   for(i = 5;  i < 5 + state->handCount[0]; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  260:      state->hand[0][i-5] = smithy;
        -:  261:   }
        1:  262:   state->discardCount[0] = 10;
       11:  263:   for(i = 0;  i < state->discardCount[0]; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  264:      state->discard[0][i] = i;
        -:  265:   }
        -:  266:
        1:  267:   struct gameState* cpy = (struct gameState*)(malloc(sizeof(struct gameState)));
        1:  268:   memcpy(cpy, state, sizeof(struct gameState));
        -:  269:
        1:  270:   smithyCard(state, 0, 0);
call    0 returned 100%
        -:  271:
        1:  272:   if(state->discardCount[0] != cpy->discardCount[0]+1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  273:	   free(cpy);
        1:  274:	   return -1;
        -:  275:   }
        -:  276:
    #####:  277:   if(state->discard[0][state->discardCount[0]-1] != smithy){
branch  0 never executed
branch  1 never executed
    #####:  278:	   free(cpy);
    #####:  279:	   return -2;
        -:  280:   }
        -:  281:
        -:  282:   //Card should exit normally as expected
    #####:  283:   free(cpy);
    #####:  284:   return 0;
        -:  285:}
        -:  286:
function totalCardCountTest called 1 returned 100% blocks executed 93%
        1:  287:int totalCardCountTest(struct gameState* state){
        -:  288:
        1:  289:   state->numPlayers = 2;
        1:  290:   state->deckCount[0] = 27;
        -:  291:
        -:  292:   int i;
        -:  293:
       28:  294:   for(i = 0;  i < state->deckCount[0]; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  295:      state->deck[0][i] = i;
        -:  296:   }
        1:  297:   state->handCount[0] = 5;
        6:  298:   for(i = 5;  i < 5 + state->handCount[0]; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:  299:      state->hand[0][i-5] = smithy;
        -:  300:   }
        1:  301:   state->discardCount[0] = 10;
       11:  302:   for(i = 0;  i < state->discardCount[0]; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       10:  303:      state->discard[0][i] = i;
        -:  304:   }
        -:  305:
        1:  306:   struct gameState* cpy = (struct gameState*)(malloc(sizeof(struct gameState)));
        1:  307:   memcpy(cpy, state, sizeof(struct gameState));
        -:  308:
        1:  309:   smithyCard(state, 0, 0);
call    0 returned 100%
        -:  310:
        1:  311:   int cardCount = 0;
        1:  312:   cardCount += state->deckCount[0] + state->handCount[0] + state->discardCount[0];
        1:  313:   if(cardCount != cpy->deckCount[0] + cpy->handCount[0] + cpy->discardCount[0]){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  314:	   return -1;
        -:  315:   }
        -:  316:   //Card should exit normally as expected
    #####:  317:   free(cpy);
    #####:  318:   return 0;
        -:  319:}
        -:  320:
function unitTest called 1 returned 100% blocks executed 83%
        1:  321:int unitTest(){
        -:  322:
        1:  323:   printf("\n+--------------------------------SMITHY CARD TEST----------------------------+\n");
call    0 returned 100%
        -:  324:   //Create Zeroed Gamestate;
        1:  325:   struct gameState* testState = (struct gameState*)(malloc(sizeof(struct gameState)));
        1:  326:   memset(testState, 0, sizeof(struct gameState));
        1:  327:   int retVal = 0;
        -:  328:
        1:  329:   printf("\n+------basicTest------+\n\n");
call    0 returned 100%
        -:  330:   ///Checks if theres a net 2 card gain in hand
        1:  331:   retVal = basicTest(testState);
call    0 returned 100%
        1:  332:   if(retVal != 0){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  333:      printf("basicTest -1: Test Failed, \n");
call    0 returned 100%
        -:  334:      //return -1
        -:  335:   } else {
    #####:  336:      printf("basicTest: Successful\n");
call    0 never executed
        -:  337:   }
        1:  338:   memset(testState, 0, sizeof(struct gameState));
        -:  339:
        1:  340:   printf("\n+--------stateTest----------+\n\n");
call    0 returned 100%
        -:  341:   //Checks to ensure expected values in current state are changed after function
        1:  342:   retVal = stateTest(testState, 8);// Expected: hand, handCount, deck, deckCount, discard, discardCount, played, playedCount
call    0 returned 100%
        1:  343:   if(retVal){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  344:	   printf("stateTest %i: Failed State Test\n", retVal);
call    0 returned 100%
        -:  345:	   //return -2;
        -:  346:   } else {
    #####:  347:		   printf("stateTest: Successful\n");
call    0 never executed
        -:  348:   }
        -:  349:
        1:  350:   printf("\n+--------discardTest----------+\n\n");
call    0 returned 100%
        -:  351:   //Checks to ensure Smithy Card is Discarded
        1:  352:   retVal = discardTest(testState);
call    0 returned 100%
        1:  353:   if(retVal){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  354:	   printf("discardTest %i: Failed Discard Test\n", retVal);
call    0 returned 100%
        -:  355:	   //return -3;
        -:  356:   } else {
    #####:  357:		   printf("discardTest: Successful\n");
call    0 never executed
        -:  358:   }
        -:  359:
        1:  360:   printf("\n+--------totalCardCountTest----------+\n\n");
call    0 returned 100%
        -:  361:   //Checks to ensure the total cards in all the piles hasn't changed
        1:  362:   retVal = totalCardCountTest(testState);
call    0 returned 100%
        1:  363:   if(retVal){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  364:	   printf("totalCardCountTest %i: Failed Total Card Count Test\n", retVal);
call    0 returned 100%
        -:  365:	   //return -3;
        -:  366:   } else {
    #####:  367:		   printf("totalCardCountTest: Successful\n");
call    0 never executed
        -:  368:   }
        -:  369:
        -:  370:
        1:  371:   free(testState);
        1:  372:   return retVal;
        -:  373:}
        -:  374:
function main called 1 returned 100% blocks executed 100%
        1:  375:int main(){
        1:  376:   int testVal = unitTest();
call    0 returned 100%
        1:  377:   printf("Outcome: %i\n", testVal);
call    0 returned 100%
        1:  378:   return testVal;
        -:  379:}
        -:  380:
